<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href = "./css/index.css" rel = "stylesheet" type="text/css">
    <title>Symbol Table Code</title>
</head>
<header>
  <nav class="mainNav">
      <ul>
          <li><a href="./projectsHome.html">Projects</a></li>
          <li><a href="./aboutMe.html">About Me</a></li>
          <li><a href="./home.html">Home</a></li>
      </ul>
  </nav>
</header>
<body class="codeDisplay">
    <p class="mycodeHighlight">symbol.c (all my own code)<br>
        #include &ltctype.h&gt<br>
        #include &ltstdio.h&gt<br>
        #include &ltstdlib.h&gt<br>
        #include &ltstring.h&gt<br>
        #include &ltstrings.h&gt<br>
        <br>
        #include "Debug.h"<br>
        #include "symbol.h"<br>
        <br>
        /** @file symbol.c<br>
         *  @brief You will modify this file and implement the symbol.h interface<br>
         *  @details Your implementation of the functions defined in symbol.h.<br>
         *  You may add other functions if you find it helpful. Added functions<br>
         *  should be declared &ltb&gtstatic&lt/b&gt to indicate they are only used<br>
         *  within this file. The reference implementation added approximately<br>
         *  110 lines of code to this file. This count includes lines containing<br>
         *  only a single closing bracket (}).<br>
         * &ltp&gt<br>
         * @author &ltb&gtYour name&lt/b&gt goes here<br>
         */<br>
         <br>
        /** size of LC3 memory */<br>
        #define LC3_MEMORY_SIZE  (1 &lt&lt 16)<br>
        <br>
        /** Provide prototype for strdup() */<br>
        char *strdup(const char *s);<br>
        <br>
        /** defines the data structure for the hash table */<br>
        struct sym_table {<br>
          int      capacity;    /**&lt length of hast_table array                  */<br>
          int      size;        /**&lt number of symbols (may exceed capacity)     */<br>
          node_t** hash_table;  /**&lt array of head of linked list for this index */<br>
          char**   addr_table;  /**&lt look up symbols by addr                     */<br>
        };<br>
        <br>
        /**************************************************************************************************************************************<br>
         djb hash - found at http://www.cse.yorku.ca/~oz/hash.html<br>
         * tolower() call to make case insensitive.<br>
         **************************************************************************************************************************************/<br>
        static int symbol_hash (const char* name) {<br>
          unsigned char* str  = (unsigned char*) name;<br>
          unsigned long  hash = 5381;<br>
          int c;<br>
          <br>
          while ((c = *str++))<br>
            hash = ((hash &lt&lt 5) + hash) + tolower(c); /* hash * 33 + c */<br>
            <br>
          c = hash & 0x7FFFFFFF; /* keep 31 bits - avoid negative values */<br>
          <br>
          return c;<br>
        }<br>
        <br>
        /***************************************************************************************************************************************<br>
         Initate a new symbol table with the specified capacity (number of indexes in hash table). <br>
         Initialize the address table and hash table contained within the symbol table. <br>
        ***************************************************************************************************************************************/<br>
        sym_table_t* symbol_init (int capacity) {<br>
          //creates the sym_table. It has size 1 because there is 1, and then the size for sym_table is allocated. <br>
          sym_table_t *sym_table_ptr = (sym_table_t  *) calloc(1, sizeof(sym_table_t));<br>
          sym_table_ptr -&gt capacity = capacity;<br>
          sym_table_ptr -&gt size = 0;<br>
          <br>
          //creates hash table (dynamic memory)<br>
          node_t **hash_table = (node_t **) calloc(capacity, sizeof(node_t *));<br>
          sym_table_ptr -&gt hash_table = hash_table;<br>
          <br>
          //allocate space for addr_table struct instance. Then saves that pointer to addr_table field in sym_table_ptr<br>
          //65536 is 2^16. That is how large the addr_table said it would be, so we allocate that much space, times the size of an address. Then we allocate the size of a char* because that is what it will hold, thus how much space it needs.<br>
          char **addr_table = (char **) calloc(65536, sizeof(char*));<br>
          sym_table_ptr -&gt addr_table = addr_table;<br>
          <br>
          return sym_table_ptr;<br>
        }<br>
        <br>
        /***************************************************************************************************************************************<br>
         helper function for symbol_reset() which free's  and clears name and address_table location from each symbol<br>
        ***************************************************************************************************************************************/<br>
        void free_names_addresses(symbol_t* sym, void *data){<br>
          //free the name of each symbol<br>
          sym -&gt name = NULL;<br>
          free(sym -&gt name);<br>
          <br>
          //clear the address table at the given symbol's address<br>
          sym_table_t* sym_tab = (sym_table_t*) data;<br>
          int address = sym -&gt addr;<br>
          char **index_in_addr = (sym_tab -&gt addr_table) + address;<br>
          *index_in_addr = NULL;<br>
        }<br>
        <br>
        /***************************************************************************************************************************************<br>
         helper function for symbol_reset() which free's and clears each node in the hash table.<br>
        ***************************************************************************************************************************************/<br>
        void free_nodes(node_t* node, void* data, void* data2){<br>
          free(node);<br>
          node = NULL;<br>
        }<br>
        <br>
        /***************************************************************************************************************************************<br>
         helper function for symbol_reset which clears each index in the hash table.<br>
        ***************************************************************************************************************************************/<br>
        void clear_hash_table(sym_table_t *sym_tab){<br>
          //sets the head of each linked list in the hash table to NULL. Does not free hash table, bc we will still need it. <br>
          node_t **hash_table = sym_tab -&gt hash_table;<br>
          for (int i = 0; i &lt (sym_tab -&gt capacity); i++){<br>
            hash_table[i] = NULL;<br>
          }<br>
        }<br>
        <br>
        /***************************************************************************************************************************************<br>
         complete destructor for symbol table<br>
        ***************************************************************************************************************************************/<br>
        void symbol_term (sym_table_t* sym_tab) {<br>
          symbol_reset(sym_tab);<br>
          free(sym_tab -&gt hash_table);<br>
          free(sym_tab -&gt addr_table);<br>
          free(sym_tab);<br>
          sym_tab = NULL;<br>
        }<br>
        <br>
        /***********************************************************************************************************************************<br>
        Clears all data from the symbol table<br>
        ************************************************************************************************************************************/<br>
        void symbol_reset(sym_table_t* sym_tab) {<br>
          symbol_iterate(sym_tab, free_names_addresses, sym_tab);<br>
          int data = 0;<br>
          int data2 = 0;<br>
          node_iterate(sym_tab, free_nodes, &data, &data2);<br>
          clear_hash_table(sym_tab);<br>
          sym_tab -&gt size = 0;<br>
        }<br>
        <br>
        /************************************************************************************************************************************<br>
        Adds a new symbol to the symbol table (both it's hash table and address table), if the symbol does not already exist. In the case of<br>
        a repeat address, the old label (name) at that address will be replaced with the new one. <br>
        @return: 0 for duplicate name, 1 otherwise<br>
        **************************************************************************************************************************************/<br>
        int symbol_add (sym_table_t* sym_tab, const char* name, int addr) {<br>
            <br>
          //create a symbol with given name and address<br>
          symbol_t sym;<br>
          char *name_save = (char *) malloc(256*sizeof(char));<br>
          strcpy(name_save, name);  //FIXME - is this line actually needed? What is it doing? <br>
          sym.name = name_save;<br>
          sym.addr = addr;<br>
          <br>
          int index;<br>
          int hash;<br>
          <br>
          //check if the address already exits. If so, replace the old node with that address<br>
          char* repeat_address_label = symbol_find_by_addr(sym_tab, addr);<br>
          if (repeat_address_label != NULL){<br>
            symbol_delete(sym_tab, repeat_address_label);<br>
          }<br>
          <br>
          //Check is the name is already in the symbol table. If it is, do not add, and return 0. Else, add and return 1. <br>
          if (symbol_search(sym_tab, name, &hash, &index) == NULL){<br>
            //create a node for the symbol<br>
            node_t* node = (node_t *) malloc(sizeof(node_t));<br>
            node -&gt symbol = sym;<br>
            node -&gt hash = hash;<br>
            <br>
            //add the node to the hash table<br>
            node_t **index_in_hash = (sym_tab -&gt hash_table) + index;<br>
            if (*index_in_hash == NULL){<br>
              node -&gt next = NULL;<br>
              *index_in_hash = node;<br>
            }<br>
            else{<br>
              node -&gt next = *index_in_hash;<br>
              *index_in_hash = node;<br>
            }<br>
            <br>
            //add the node to the address table<br>
            char * name_ptr = sym.name;<br>
            int addr_index = sym.addr;<br>
            char **index_in_addr = (sym_tab -&gt addr_table) + addr_index;<br>
            if (*index_in_addr == NULL){<br>
              *index_in_addr = name_ptr;<br>
            }<br>
            <br>
            //increment size of sym_tab<br>
            (sym_tab -&gt size)++; <br>
            <br>
            return 1;<br>
          } <br>
          return 0;<br>
        }<br>
        <br>
        /************************************************************************************************************************************<br>
        Deletes a node with a given name from the hash table. <br>
        **************************************************************************************************************************************/<br>
        void symbol_delete(sym_table_t* sym_tab, const char* name){<br>
          node_t* previous_node = NULL;<br>
          int hash = symbol_hash(name);<br>
          int index = hash % (sym_tab -&gt capacity);<br>
          <br>
          node_t **index_in_hash = (sym_tab -&gt hash_table) + index;<br>
          <br>
          if (*index_in_hash != NULL){<br>
            node_t *current_node_ptr = *index_in_hash;<br>
            while (current_node_ptr != NULL){<br>
              //when node with matching label (name) is found, remove it from the linked list at that hash index<br>
              if (strcasecmp((current_node_ptr -&gt symbol).name, name) == 0){<br>
                if (previous_node == NULL){<br>
                  *index_in_hash = current_node_ptr -&gt next;<br>
                }<br>
                else{<br>
                  previous_node -&gt next = current_node_ptr -&gt next;<br>
                }<br>
                (sym_tab -&gt size)--;<br>
                free(current_node_ptr -&gt symbol.name);<br>
                free(current_node_ptr);<br>
                current_node_ptr = NULL;<br>
                return;<br>
              }<br>
              previous_node = current_node_ptr;<br>
              current_node_ptr = current_node_ptr -&gt next;<br>
            }<br>
          }<br>
          return;<br>
        }<br>
        <br>
        /*************************************************************************************************************************<br>
        Determines if given symbol name is already present in the array. <br>
        @return: NULL if symbol is not present, otherwise node ptr holding the matching symbol<br>
        @param: int* hash: saves raw hash value associated with symbol to passed in variable<br>
        @param: int* index: saves hash index associate with symbol to passed in variable<br>
        **************************************************************************************************************************/<br>
        struct node* symbol_search (sym_table_t* sym_tab, const char* name, int* hash, int* index) {<br>
          int hash_val = symbol_hash(name);<br>
          *hash = hash_val;<br>
          int index_val = *hash % (sym_tab -&gt capacity);<br>
          *index = index_val;<br>
          <br>
          //go to the beginning of the correct index (beginning of linked list) in the hash table<br>
          node_t **index_in_hash = (sym_tab -&gt hash_table) + *index;<br>
          <br>
          //if the value at that hash index is NULL, we can immediately return NULL, because there are no values in the linked list at this index. Else, we search through that index's linked list for it.<br>
          if (*index_in_hash != NULL){<br>
            //doubleReferencing index_in_hash gives us the head node of the appropriate linked list.<br>
            node_t *current_node_ptr = *index_in_hash;<br>
            while (current_node_ptr != NULL){<br>
              if (strcasecmp((current_node_ptr -&gt symbol).name, name) == 0){<br>
                return current_node_ptr;<br>
              }<br>
              if (current_node_ptr -&gt next == NULL){<br>
                  return NULL;<br>
              }<br>
              <br>
              current_node_ptr = current_node_ptr -&gt next;<br>
            }<br>
          }<br>
          return NULL;<br>
        }<br>
        <br>
        /*******************************************************************************************************************************<br>
         Retrieves the symbol matching a given name.<br>
         @return: NULL is no matching symbol names are found. Otherwise, pointer to the matching symbol.<br>
         ********************************************************************************************************************************/<br>
        symbol_t* symbol_find_by_name (sym_table_t* sym_tab, const char* name) {<br>
          int hash, index;<br>
          node_t* symbol_val = symbol_search(sym_tab, name, &hash, &index);<br>
          if (symbol_val != NULL){<br>
            symbol_t* sym = &(symbol_val -&gt symbol);<br>
            return sym;<br>
          }<br>
          return NULL;<br>
        }<br>
        <br>
        /***********************************************************************************************************************************<br>
         Retrieves the symbol name found at a given address.<br>
        @return: NULL if no symbol exists at the given address. Else the symbol name at the given address<br>
         **********************************************************************************************************************************/<br>
        char* symbol_find_by_addr (sym_table_t* sym_tab, int addr) {<br>
          char **labelPtr = sym_tab -&gt addr_table;<br>
          labelPtr += addr;<br>
          if (*labelPtr != NULL){<br>
            return *labelPtr;<br>
          }<br>
          return NULL;<br>
        }<br>
        <br>
        /**************************************************************************************************************************************<br>
        Iterates through each symbol in the hash table, performing a function on each one<br>
        @param: fnc: function to perform on each symbol<br>
        @param: data: pointer to needed data for the dunction<br>
        ***************************************************************************************************************************************/<br>
        void symbol_iterate (sym_table_t* sym_tab, iterate_fnc_t fnc, void* data) {<br>
          node_t **hash_table = sym_tab -&gt hash_table;<br>
          <br>
          for (int i = 0; i &lt (sym_tab -&gt capacity); i++){<br>
            node_t **current_hash_index = hash_table + i;<br>
            node_t *current_node_ptr = *current_hash_index;<br>
            <br>
            while (current_node_ptr != NULL){<br>
              symbol_t *symbol = &(current_node_ptr -&gt symbol);<br>
              (*fnc)(symbol, data); <br>
              current_node_ptr = current_node_ptr -&gt next;<br>
            }<br>
          }<br>
        }<br>
        <br>
        /**************************************************************************************************************************************<br>
        Iterates through each node in the hash table, performing a function on each one<br>
        @param: fnc: function to perform on each node<br>
        @param: data: pointer to needed data for the function<br>
        @param: data2: other information which can be passed in<br>
        ***************************************************************************************************************************************/<br>
        void node_iterate(sym_table_t* sym_tab, iterate_fnc2_t fnc, void* data, void* data2) {<br>
          node_t **hash_table = sym_tab -&gt hash_table;<br>
          <br>
          for (int i = 0; i &lt (sym_tab -&gt capacity); i++){<br>
            node_t **current_hash_index = hash_table + i;<br>
            node_t *current_node_ptr = *current_hash_index;<br>
            <br>
            while (current_node_ptr != NULL){<br>
              //avoids dangling pointer call when fnc is free_nodes()<br>
              node_t* next = (current_node_ptr -&gt next);<br>
              (*fnc)(current_node_ptr, data, data2); <br>
              current_node_ptr = next;<br>
            }<br>
          }<br>
        }<br>
        <br>
        /*****************************************************************************************************************************************<br>
        Returns size of the symbol table<br>
        *****************************************************************************************************************************************/<br>
        int symbol_size (sym_table_t* sym_tab) {<br>
          return sym_tab -&gt size;<br>
        }<br>
        <br>
        /******************************************************************************************************************************************<br>
        Sorts an array of symbol_t* by symbol name. Helper function for qsort() in symbol_order().<br>
        *******************************************************************************************************************************************/<br>
        int compare_names (const void* vp1, const void* vp2) {<br>
          symbol_t* sym1 = *((symbol_t**) vp1);<br>
          symbol_t* sym2 = *((symbol_t**) vp2);<br>
          return strcasecmp(sym1 -&gt name, sym2 -&gt name);<br>
        }<br>
        <br>
        /******************************************************************************************************************************************<br>
        Sorts an array of symbol_t* by symbol address. Helper function for qsort() in symbol_order().<br>
        *******************************************************************************************************************************************/<br>
        int compare_addresses (const void* vp1, const void* vp2) {<br>
          symbol_t* sym1 = *((symbol_t**) vp1);<br>
          symbol_t* sym2 = *((symbol_t**) vp2);<br>
          if ((sym1 -&gt addr) &lt (sym2 -&gt addr)){<br>
            return -1;<br>
          }<br>
          else if ((sym2 -&gt addr) &lt (sym1 -&gt addr)){<br>
            return 1;<br>
          }<br>
          return 0; <br>
        }<br>
        <br>
        <br>
        void symbol_order_helper(node_t* node, void* data, void* data2){<br>
          int* currentIndex = (int*) data2;<br>
          symbol_t *symbol_ptr = &(node -&gt symbol);<br>
          symbol_t** sorted_symbol_array = (symbol_t**) data;<br>
          sorted_symbol_array[*currentIndex] = symbol_ptr;<br>
          (*currentIndex)++;<br>
        }<br>
        <br>
        /******************************************************************************************************************************************<br>
        creates a new array of symbol_t * and sorts the array based on order. <br>
        Possible values for order: HASH (0) NAME (1) ADDR (2)<br>
        *******************************************************************************************************************************************/<br>
        symbol_t** symbol_order (sym_table_t* sym_tab, int order) {<br>
          if (symbol_size(sym_tab) == 0){<br>
            return NULL; <br>
          }<br>
          <br>
          //dynamically allocate symbol_t* [] <br>
          symbol_t **sorted_symbol_array = (symbol_t**) calloc(symbol_size(sym_tab), sizeof(symbol_t *)); <br>
          <br>
          //iterate thorugh each node and add its symbol into sorted_symbol_array<br>
          int current_index = 0;<br>
          node_iterate(sym_tab, symbol_order_helper, sorted_symbol_array, &current_index);<br>
          <br>
          //sort based on order criteria<br>
          switch (order){<br>
            case 0:<br>
              break;<br>
            case 1:<br>
              qsort(sorted_symbol_array, symbol_size(sym_tab), sizeof(symbol_t *), compare_names); <br>
              break;<br>
             case 2: <br>
              qsort(sorted_symbol_array, symbol_size(sym_tab), sizeof(symbol_t *), compare_addresses); <br>
              break;<br>
          }<br>
          <br>
          return sorted_symbol_array; <br>
        }<br>
    </p>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <p>symbol.h (Provided by Instructor)<br>
        #ifndef __SYMBOL_H__<br>
        #define __SYMBOL_H__<br>
        <br>
        /** used when list order is order in hash table */<br>
        #define HASH  0<br>
        <br>
        /** used when list order is alphabetical by name */<br>
        #define NAME 1<br>
        <br>
        /** used when list order is by increasing address */<br>
        #define ADDR 2<br>
        <br>
        typedef struct sym_table sym_table_t;<br>
        <br>
        /** symbol_find method returns a pointer to this data structure.<br>
        */<br>
        typedef struct symbol {<br>
            char* name; /**&lt the name of the symbol */<br>
            int   addr; /**&lt symbol's address in the LC3 memory */<br>
        } symbol_t;<br>
        <br>
        /** defines data structure used to store nodes in hash table */<br>
        typedef struct node {<br>
        struct node* next;     /**&lt linked list of symbols at same index */<br>
        int          hash;     /**&lt hash value - makes searching faster  */<br>
        symbol_t     symbol;   /**&lt the data the user is interested in   */<br>
        } node_t;<br>
        <br>
        int symbol_add (sym_table_t* symTab, const char* name, int addr);<br>
        <br>
        void symbol_delete(sym_table_t* sym_tab, const char* name);<br>
        <br>
        char* symbol_find_by_addr (sym_table_t* symTab, int addr);<br>
        <br>
        symbol_t* symbol_find_by_name (sym_table_t* symTab, const char* name);<br>
        <br>
        sym_table_t* symbol_init (int capacity);<br>
        <br>
        void symbol_reset (sym_table_t* symTab);<br>
        <br>
        struct node* symbol_search (sym_table_t* symTab, const char* name, int* hash, int* index);<br>
        <br>
        void symbol_term(sym_table_t* symTab);<br>
        <br>
        typedef void (*iterate_fnc_t)(symbol_t* sym, void* data);<br>
        <br>
        typedef void (*iterate_fnc2_t)(node_t* node, void* data, void* data2);<br>
        <br>
        void symbol_iterate (sym_table_t* symTab, iterate_fnc_t fnc, void* data);<br>
        <br>
        void node_iterate (sym_table_t* symTab, iterate_fnc2_t fnc, void* data, void* data2);<br>
        <br>
        int compare_names (const void* vp1, const void* vp2);<br>
        <br>
        int compare_addresses (const void* vp1, const void* vp2);<br>
        <br>
        int symbol_size (sym_table_t* symTab);<br>
        <br>
        symbol_t** symbol_order (sym_table_t* symTab, int order);<br>
        <br>
        #endif /* __SYMBOL_H__ */<br>
    </p>


    <p>testsymbol.c (Provided by Instructor)<br>
        <br>
        #include &ltstdio.h&gt<br>
        #include &ltstdlib.h&gt<br>
        #include &ltstring.h&gt<br>
        <br>
        #include "Debug.h"<br>
        #include "symbol.h"<br>
        <br>
        /** Maximum length of command line processed */<br>
        #define MAX_LINE_LENGTH 128<br>
        <br>
        /** Delimiter used separate tokens on line - used by strtok() */<br>
        const char *delim = " \t";<br>
        <br>
        /** Print a usage statement describing how program is used */<br>
        static void help() {<br>
        puts("Usage: testSymbol [-debug]\n");<br>
        puts("then enter commands from keyboard, one per line:\n");<br>
        puts("init capacity    - create symbol table with given capacity");<br>
        puts("                     MUST be first action taken");<br>
        puts("add name address - prints 1 on succeses, 0 on failure");<br>
        puts("count            - prints count of names/addresses");<br>
        puts("                     uses function pointers");<br>
        puts("debug level      - turn debug on/off (0 is off)");<br>
        puts("exit/quit        - terminates program");<br>
        puts("get name         - prints NULL or name/address");<br>
        puts("label address    - prints NULL or name associated with address");<br>
        puts("list             - prints all names/addresses");<br>
        puts("                     uses function pointers");<br>
        puts("order option     - calls symbol_order and print value(s)");<br>
        puts("                 - option is HASH|NAME|ADDR");<br>
        puts("search name      - prints NULL or name/address and hash/index");<br>
        puts("size             - call symbol_size()");<br>
        puts("reset            - call symbol_reset()\n");<br>
        }
        <br>
        /** Print a usage statement describing how program is used, and exits */<br>
        static void usage() {<br>
        help();<br>
        }<br>
        <br>
        /** get the next token from the input<br>
        *  @return the token, or exit with error<br>
        */<br>
        static char* nextToken () {<br>
        char* tok = strtok(NULL, delim);<br>
        if (! tok)<br>
            usage();<br>
        return tok;<br>
        }<br>
        <br>
        /** Get an integer from the input<br>
        *  @return the value, or exit with error<br>
        */<br>
        static int nextInt() {<br>
        char* junk;<br>
        char* tok = nextToken();<br>
        return (int) strtol(tok, &junk, 0);<br>
        }<br>
        <br>
        /** Example of a call back function called via symbol_iterate()<br>
        */<br>
        static void countSymbols (symbol_t* sym, void *data) {<br>
        int* ip = (int*) data;<br>
        *ip = *ip + 1;<br>
        }<br>
        <br>
        /** Another example of a call back function called via symbol_iterate()<br>
        */<br>
        static void printResult(symbol_t* sym, void* data) {<br>
        FILE* f = (FILE*) data;<br>
        <br>
        if (! sym)<br>
            fprintf(f, "NULL\n");<br>
        else<br>
            fprintf(f, "name:%-20s addr:%-6d\n", sym-&gtname, sym-&gtaddr);<br>
        }<br>
        <br>
        /** Test the symbol_order() function */<br>
        static void printList (sym_table_t* symTab, int order) {<br>
        int        size = symbol_size(symTab);<br>
        symbol_t** list = symbol_order(symTab, order);<br>
        <br>
        if (list) {<br>
            for (int i = 0; i &lt size; i++)<br>
            printResult(list[i], stdout);<br>
            <br>
            puts("");<br>
            free(list);<br>
        }<br>
        }<br>
        <br>
        /** Entry point of the program<br>
        * @param argc count of arguments, will always be at least 1<br>
        * @param argv array of parameters to program argv[0] is the name of<br>
        * the program, so additional parameters will begin at index 1.<br>
        * @return 0 the Linux convention for success.<br>
        */<br>
        int main (int argc, const char* argv[]) {<br>
        char line[MAX_LINE_LENGTH];<br>
        int  count, addr;<br>
        char *cmd, *name;<br>
        sym_table_t* symTab = NULL;<br>
        <br>
        debugInit(&argc, argv);<br>
        <br>
        if (argc != 1)<br>
            usage();<br>
            <br>
        while (fgets(line, sizeof(line), stdin) != NULL) {<br>
            char *cr = strchr(line ,'\n'); /* get rid of trailing \n, if any */<br>
            <br>
            if (cr)<br>
            *cr = '\0';<br>
            <br>
            cmd = strtok(line, delim);<br>
            <br>
            if ((! cmd) || (*cmd == '#')) // skip blank lines, comments<br>
            continue;<br>
            <br>
            if (strcmp(cmd, "debug") == 0) {<br>
            debugLevel  = nextInt();<br>
            }<br>
            else if ((strcmp(cmd, "exit") == 0) || (strcmp(cmd, "quit") == 0)) {<br>
            break;<br>
            }<br>
            else if (strcmp(cmd, "help") == 0) {<br>
            help();<br>
            }<br>
            else if (strcmp(cmd, "init") == 0) {<br>
            count  = nextInt();<br>
            symTab = symbol_init(count);<br>
            debug("initialized with size %d", count);<br>
            }<br>
            else if (symTab == NULL) {<br>
            puts("Please initialize symbol table before use");<br>
            }<br>
            else if (strcmp(cmd, "add") == 0) {<br>
            name = nextToken();<br>
            addr = nextInt();<br>
            printf("%s\n", (symbol_add(symTab, name, addr) ? "OK" : "Duplicate"));<br>
            }<br>
            else if (strcmp(cmd, "term") == 0) {<br>
            symbol_term(symTab);<br>
            }<br>
            else if (strcmp(cmd, "count") == 0) {<br>
            count = 0;<br>
            symbol_iterate(symTab, countSymbols, &count);<br>
            printf("symbol count: %d\n", count);<br>
            }<br>
            else if (strcmp(cmd, "get") == 0) {<br>
            name = nextToken();<br>
            printResult(symbol_find_by_name(symTab, name), stdout);<br>
            }<br>
            else if (strcmp(cmd, "label") == 0) {<br>
            addr = nextInt();<br>
            printf("label at addr %d '%s'\n", addr,<br>
                    symbol_find_by_addr(symTab, addr));<br>
            }<br>
            else if (strcmp(cmd, "list") == 0) {<br>
            symbol_iterate(symTab, printResult, stdout);<br>
            puts("");<br>
            }<br>
            else if (strcmp(cmd, "order") == 0) {<br>
            name = nextToken();<br>
            if (strcmp(name, "HASH") == 0)<br>
                printList(symTab, HASH);<br>
            else if (strcmp(name, "NAME") == 0)<br>
                printList(symTab, NAME);<br>
            else if (strcmp(name, "ADDR") == 0)<br>
                printList(symTab, ADDR);<br>
            else<br>
                help();<br>
            }<br>
            else if (strcmp(cmd, "reset") == 0) {<br>
            symbol_reset(symTab);<br>
            }<br>
            else if (strcmp(cmd, "search") == 0) {<br>
            int hash, index;<br>
            name              = nextToken();<br>
            struct node* node = symbol_search(symTab, name, &hash, &index);<br>
            printf("symbol '%s' hash: %d index: %d is %s in symbol table\n", name,<br>
                    hash, index, (node ? "" : "NOT"));<br>
            }<br>
            else if (strcmp(cmd, "size") == 0) {<br>
            printf("symbol table contains %d entries\n", symbol_size(symTab));<br>
            }<br>
            else {<br>
            help();<br>
            }<br>
        }<br>
        <br>
        symbol_term(symTab); /* can check for memory leaks now */<br>
        <br>
        return 0;<br>
        }<br>
    </p>
</body>
</html>