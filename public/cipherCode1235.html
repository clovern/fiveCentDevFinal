<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href = "./css/index.css" rel = "stylesheet" type="text/css">
    <title>Cipher Code</title>
</head>
<header>
    <nav class="mainNav">
        <ul>
            <li><a href="./projectsHome.html">Projects</a></li>
            <li><a href="./aboutMe.html">About Me</a></li>
            <li><a href="./home.html">Home</a></li>
        </ul>
    </nav>
</header>
<body class="codeDisplay">
    <p>
        cipher.cpp
        
        #include &ltstring&gt<br>
        #include &ltiostream&gt<br>
        #include &ltfstream&gt<br>
        #include &ltcstring&gt<br>
        #include &ltsstream&gt<br>
        #include &ltbitset&gt<br>
            <br>
        using namespace std;<br>
            <br>
        void read_xor_block(istream& in, string& key, string& transform, bool encrypting){<br>
            string block;<br>
            char c;<br>
            <br>
            //read in the file to be encrypted/decrypted, one 16 byte block at a time<br>
            int counter = 0;<br>
            while (in.get(c)){<br>
                block += c;<br>
                counter++;<br>
                if (counter == 16){<br>
                    for (size_t i = 0; i &lt block.length();  i++){<br>
                        unsigned char block_char = block[i];<br>
                        unsigned char key_char = key[i];<br>
                        unsigned char temp = block_char ^ key_char;<br>
                        transform += temp;<br>
                    }<br>
                    block = "";<br>
                    counter = 0;<br>
                }<br>
            }<br>
            <br>
            //pad the last block with Ox81 ascii character, then xor it.<br>
            if (encrypting == true){<br>
                while (block.length() &lt 16){<br>
                    block += '\x81';<br>
                }<br>
            }<br>
            for (size_t i = 0; i &lt block.length();  i++){<br>
                unsigned char block_char = block[i];<br>
                unsigned char key_char = key[i];<br>
                unsigned char temp = block_char ^ key_char;<br>
                transform += temp;<br>
            }<br>
            if (encrypting == false){<br>
                int i = transform.length() -1;<br>
                while (transform[i] == '\x81'){<br>
                    transform.pop_back();<br>
                    i--;<br>
                }<br>
                <br>
            }<br>
        }<br>
            <br>
        /*until you get to the end of output, check if key[key_index] % 2 == 1. If yes, swap values at start and end and then increment/decrement start/end (respectively).<br>
        If no, just increment start. Then check the next index in the key. */<br>
        void swap(string& output, string key){<br>
            size_t start = 0;<br>
            size_t key_index = 0;<br>
            size_t end = output.length() - 1;<br>
            while (start &lt end){<br>
                unsigned char key_value = key[key_index % 16];<br>
                if (key_value % 2 == 1){<br>
                    char temp = output[start];<br>
                    output[start] = output[end];<br>
                    output[end] = temp;<br>
                    end--;<br>
                }<br>
                start++;<br>
                key_index++;<br>
            }<br>
        }<br>
            <br>
        void block_cipher_encrypt(ifstream& in, ifstream& keyfile, string outfile){<br>
            string key;<br>
            string encrypted;<br>
            char c;<br>
            <br>
            //checks for the case that the file is empty, and if so simply returns without encrypting anything.<br>
            in.get(c);<br>
            if (in.eof()){<br>
                ofstream out(outfile);<br>
                return;<br>
            }<br>
            in.unget();<br>
            in.clear();<br>
            <br>
            //read in the keyfile<br>
            while (keyfile.get(c)){<br>
                key += c;<br>
            }<br>
            <br>
            //read in the data in blocks and xor it<br>
            read_xor_block(in, key, encrypted, true);<br>
            <br>
            swap(encrypted, key);<br>
            <br>
            <br>
            //output the encrypted string to the output file<br>
            ofstream out(outfile);<br>
            out &lt&lt encrypted;<br>
        }<br>
            <br>
        void block_cipher_decrypt(ifstream& in, istream& keyfile, string outfile){<br>
            string key;<br>
            string ciphertext;<br>
            string decrypted;<br>
            char c;<br>
            <br>
            //checks for the case that the file is empty, and if so simply returns without encrypting anything.<br>
            in.get(c);<br>
            if (in.eof()){<br>
                ofstream out(outfile);<br>
                return;<br>
            }<br>
            in.unget();<br>
            in.clear();<br>
            <br>
            //read in the keyfile<br>
            while (keyfile.get(c)){<br>
                key += c;<br>
            }<br>
            <br>
            //read in the input (ciphertext) file<br>
            while (in.get(c)){<br>
                ciphertext += c;<br>
            }<br>
            <br>
            swap(ciphertext, key);<br>
            <br>
            // //turn decrypted into a stringsream, so that it can be passed into read_xor_block<br>
            istringstream iss(ciphertext);<br>
            <br>
            //read in the data in blocks and xor it<br>
            read_xor_block(iss, key, decrypted, false);<br>
            <br>
            ofstream out(outfile);<br>
            out &lt&lt decrypted;<br>
        }<br>
            <br>
        //this function takes a key of set size, instead of the typical key matching the length of file to encrypt, due to the specifications of the assignment<br>
        void stream_cipher(istream&in, istream& keyfile, string outfile){<br>
            string key;<br>
            <br>
            ofstream out(outfile);<br>
            <br>
            //read in the key: entire key read at once since it is not necessarily the same length as the textfile.<br>
            char k;<br>
            while (keyfile.get(k)){<br>
                key += k;<br>
            }<br>
            <br>
            char c;<br>
            int counter = 0;<br>
            //read in one character at a time from the file<br>
            while (in.get(c)){<br>
            <br>
                //store the bits of the input character and the key character in a bitset<br>
                bitset&lt8&gt inbits(c);<br>
                <br>
                //xor a bit from the input file character with a bit from the keyfile character, one bit at a time. Store the result in a bitset<br>
                bitset&lt8&gt keybits(key[counter % (key.length())]);<br>
                for (int i=0; i&lt8; i++){<br>
                    inbits[i] = inbits[i] ^ keybits[i];<br>
                }<br>
            <br>
                //convert the completed bitset back into an ascii character and output it to the output file.<br>
                string newstring = inbits.to_string();<br>
                char newchar = static_cast&ltchar&gt(stoi(newstring, 0, 2));<br>
                out &lt&lt newchar;<br>
            <br>
                //increment which character in the key we are looking at<br>
                counter++;<br>
            }<br>
        }<br>
            <br>
        int main(int argc, char* argv[]){<br>
            //check arguments for validity<br>
            if (argc != 6){<br>
                throw runtime_error(argv[0] + ": invalid number of arguments provided. Correct format is &ltprogram name&gt &ltcipher mode ('B' or 'S')&gt \n\<br>
                &ltinput filename&gt &ltoutput filename&gt &ltkeyfile filename&gt &ltmode: ('E' or 'D')&gt"s);<br>
            }<br>
            <br>
            string cipher_type;<br>
            string input_file = argv[2];<br>
            string output_file = argv[3];<br>
            string keyfile = argv[4];<br>
            string mode;<br>
            <br>
            if (string(argv[1]) != "B" && string(argv[1]) != "S"){<br>
                throw runtime_error(argv[0] + ": argument &lt"s + argv[1] + "&gt is not a valid choice. Valid options are 'B' or 'S'.");<br>
            }<br>
            cipher_type = argv[1];<br>
            <br>
            ifstream keyin (keyfile);<br>
                if (!keyin){<br>
                throw runtime_error(argv[0] + ": keyfile &lt"s + argv[4] + "&gt is not a valid file.");<br>
            }<br>
            <br>
            if (string(argv[5]) != "E" && string(argv[5]) != "D"){<br>
                throw runtime_error(argv[0] + ": argument &lt"s + argv[5] + "&gt is not a valid choice. Valid options are 'E' or 'D'.");<br>
            }<br>
            mode = argv[5];<br>
            <br>
            ifstream in(input_file);<br>
            if (!in){<br>
                throw runtime_error(argv[0] + ": filename &lt"s + argv[2] + "&gt cannot be opened.");<br>
            }<br>
            if (cipher_type == "B"){<br>
                if (mode == "E"){<br>
                    block_cipher_encrypt(in, keyin, output_file);<br>
                }<br>
                else if (mode == "D"){<br>
                    block_cipher_decrypt(in, keyin, output_file);<br>
                }<br>
            }<br>
            else if (cipher_type == "S"){<br>
                stream_cipher(in, keyin, output_file);<br>
            }<br>
        }            <br>
    </p>
</body>

</html>